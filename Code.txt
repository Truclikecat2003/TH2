import React, { useState, useEffect, useRef } from 'react'; // Import c√°c hook c·∫ßn thi·∫øt c·ªßa React
import { View, Text, TouchableOpacity, StyleSheet, Switch, Animated } from 'react-native'; // Import c√°c th√†nh ph·∫ßn giao di·ªán t·ª´ React Native
import { Entypo } from '@expo/vector-icons'; // Import bi·ªÉu t∆∞·ª£ng t·ª´ th∆∞ vi·ªán Entypo
import { Audio } from 'expo-av'; // Import th∆∞ vi·ªán √¢m thanh t·ª´ Expo
import styles from './Style'; // Import styles t·ª´ m·ªôt file b√™n ngo√†i

export default function App() {
  // Khai b√°o state ƒë·ªÉ qu·∫£n l√Ω c√°c gi√° tr·ªã c·∫ßn thi·∫øt trong ·ª©ng d·ª•ng
  const [expression, setExpression] = useState('');  // Bi·ªÉu th·ª©c ng∆∞·ªùi d√πng nh·∫≠p v√†o
  const [result, setResult] = useState('');          // K·∫øt qu·∫£ t√≠nh to√°n
  const [isDark, setIsDark] = useState(false);       // Ch·∫ø ƒë·ªô t·ªëi (dark mode)
  const [cursorIndex, setCursorIndex] = useState(0); // Ch·ªâ s·ªë con tr·ªè ƒë·ªÉ ƒëi·ªÅu khi·ªÉn v·ªã tr√≠ con tr·ªè
  const [showThemes, setShowThemes] = useState(false); // Hi·ªÉn th·ªã l·ª±a ch·ªçn ch·∫ø ƒë·ªô giao di·ªán
  const [displayEnabled, setDisplayEnabled] = useState(true); // ƒêi·ªÅu khi·ªÉn vi·ªác hi·ªÉn th·ªã c√°c t√≠nh nƒÉng

  // Kh·ªüi t·∫°o animation ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng nh·∫•p nh√°y cho con tr·ªè
  const blinkAnim = useRef(new Animated.Value(0)).current;

  // Hook useEffect ƒë·ªÉ ch·∫°y hi·ªáu ·ª©ng nh·∫•p nh√°y cho con tr·ªè
  useEffect(() => {
    Animated.loop(
      Animated.sequence([ 
        Animated.timing(blinkAnim, { // T·∫°o hi·ªáu ·ª©ng nh·∫•p nh√°y
          toValue: 1,
          duration: 500,
          useNativeDriver: true,
        }),
        Animated.timing(blinkAnim, { 
          toValue: 0,
          duration: 500,
          useNativeDriver: true,
        }),
      ])
    ).start();
  }, [blinkAnim]); // L·∫∑p l·∫°i khi bi·∫øn blinkAnim thay ƒë·ªïi

  // Danh s√°ch c√°c n√∫t b·∫•m tr√™n giao di·ªán
  const buttons = [
    ['Shift', 'Ans', '‚¨ÜÔ∏è', 'ON', 'OFF'],
    ['Giao di·ªán', '‚¨ÖÔ∏è', 'üîµ', '‚û°Ô∏è', 'Sin'],
    ['C', 'AC', '‚¨áÔ∏è', '+', 'Cos'],
    ['7', '8', '9', '-', 'Tan'],
    ['4', '5', '6', '*', 'Cot'],
    ['1', '2', '3', '/', 'CƒÉn'],
    ['0', '.', '^', '%', '='],
  ];

  // H√†m ph√°t √¢m thanh khi b·∫•m n√∫t
  const playSound = async (type) => {
    try {
      const sound = new Audio.Sound();
      await sound.loadAsync(
        type === 'click'
          ? require('./amthanh/click.wav') // √Çm thanh khi b·∫•m n√∫t
          : require('./amthanh/error.wav') // √Çm thanh khi c√≥ l·ªói
      );
      await sound.playAsync(); // Ph√°t √¢m thanh
    } catch (error) {
      console.log('L·ªói √¢m thanh:', error); // In l·ªói n·∫øu c√≥ s·ª± c·ªë khi ph√°t √¢m thanh
    }
  };

  // H√†m x·ª≠ l√Ω khi b·∫•m v√†o m·ªôt n√∫t
  const handlePress = async (value) => {
    
    // Ki·ªÉm tra n·∫øu trong bi·ªÉu th·ª©c c√≥ '/0' (chia cho 0), ph√°t √¢m thanh l·ªói
    if (expression.includes('/0')) {
      await playSound('error'); // Ph√°t √¢m thanh l·ªói
      resetExpression(); // Reset bi·ªÉu th·ª©c
      return;
    }
    // Ph√°t √¢m thanh click cho c√°c n√∫t kh√°c
    await playSound('click'); 
    
    // N·∫øu t√≠nh nƒÉng hi·ªÉn th·ªã b·ªã t·∫Øt, kh√¥ng cho ph√©p b·∫•m n√∫t tr·ª´ khi l√† ON/OFF
    if (!displayEnabled && value !== 'ON' && value !== 'OFF') {
      if (['C', 'AC'].includes(value)) { // X·ª≠ l√Ω khi b·∫•m C ho·∫∑c AC
        resetExpression();
      } else if (value === '=') { // T√≠nh to√°n k·∫øt qu·∫£ khi b·∫•m "="
        calculateResult();
      } else { // Th√™m gi√° tr·ªã v√†o bi·ªÉu th·ª©c
        appendExpression(value);
      }
      return;
    }

    // C√°c tr∆∞·ªùng h·ª£p x·ª≠ l√Ω khi t√≠nh nƒÉng hi·ªÉn th·ªã ƒë∆∞·ª£c b·∫≠t
    if (['C', 'AC'].includes(value)) {
      resetExpression();
    } else if (value === '=') {
      calculateResult();
    } else {
      appendExpression(value);
    }
  };

  // H√†m ƒë·∫∑t l·∫°i bi·ªÉu th·ª©c
  const resetExpression = () => {
    setExpression(''); // ƒê·∫∑t l·∫°i bi·ªÉu th·ª©c
    setCursorIndex(0); // ƒê·∫∑t l·∫°i v·ªã tr√≠ con tr·ªè
    setShowThemes(false); // ·∫®n l·ª±a ch·ªçn giao di·ªán
  };

  // H√†m t√≠nh to√°n k·∫øt qu·∫£
  const calculateResult = async () => {
    try {
      // Ki·ªÉm tra chia cho 0 v√† l·ªói c√∫ ph√°p
      if (/4\/0+$/.test(expression)) {
        await playSound('error'); // Ph√°t √¢m thanh l·ªói
        setResult('Kh√¥ng h·ª£p l·ªá');
      } else {
        setResult(eval(expression).toString()); // T√≠nh to√°n k·∫øt qu·∫£ v√† hi·ªÉn th·ªã
      }
    } catch {
      setResult('Error'); // N·∫øu c√≥ l·ªói trong khi t√≠nh to√°n
    }
  };

  // H√†m th√™m k√Ω t·ª± v√†o bi·ªÉu th·ª©c
  const appendExpression = (value) => {
    setExpression((prev) => prev + value); // Th√™m k√Ω t·ª± m·ªõi v√†o bi·ªÉu th·ª©c
    setCursorIndex((prev) => prev + 1); // C·∫≠p nh·∫≠t v·ªã tr√≠ con tr·ªè
  };

  // H√†m di chuy·ªÉn con tr·ªè sang tr√°i
  const moveCursorLeft = () => {
    setCursorIndex((prev) => (prev > 0 ? prev - 1 : expression.length - 1));
  };
  
  // H√†m di chuy·ªÉn con tr·ªè sang ph·∫£i
  const moveCursorRight = () => {
    setCursorIndex((prev) => (prev < expression.length - 1 ? prev + 1 : 0));
  };

  // H√†m x√≥a k√Ω t·ª± ·ªü v·ªã tr√≠ con tr·ªè
  const deleteCharacter = () => {
    if (expression.length > 0 && cursorIndex > 0) {
      const updated = expression.slice(0, cursorIndex - 1) + expression.slice(cursorIndex); // C·∫Øt b·ªè k√Ω t·ª±
      setExpression(updated); // C·∫≠p nh·∫≠t l·∫°i bi·ªÉu th·ª©c
      setCursorIndex((prev) => (prev > 0 ? prev - 1 : 0)); // C·∫≠p nh·∫≠t v·ªã tr√≠ con tr·ªè
    }
  };

  // H√†m x·ª≠ l√Ω khi b·∫•m n√∫t Ans (s·ª≠ d·ª•ng k·∫øt qu·∫£ tr∆∞·ªõc ƒë√≥)
  const handleAns = () => {
    if (result !== '') {
      setExpression(result); // Th√™m k·∫øt qu·∫£ v√†o bi·ªÉu th·ª©c
      setCursorIndex(result.length); // C·∫≠p nh·∫≠t con tr·ªè
    }
  };

  // H√†m x·ª≠ l√Ω vi·ªác ch·ªçn giao di·ªán
  const handleThemeSelection = () => {
    if (displayEnabled) {
      setExpression(expression + '\nS√°ng | T·ªëi | Xanh | ƒê∆°n gi·∫£n'); // Th√™m l·ª±a ch·ªçn ch·∫ø ƒë·ªô v√†o bi·ªÉu th·ª©c
      setShowThemes(true); // Hi·ªÉn th·ªã l·ª±a ch·ªçn ch·∫ø ƒë·ªô giao di·ªán
    }
  };

  // H√†m x·ª≠ l√Ω khi ng∆∞·ªùi d√πng ch·ªçn m·ªôt ch·∫ø ƒë·ªô giao di·ªán
  const handleSelectTheme = (theme) => {
    setIsDark(theme === 'T·ªëi'); // Thay ƒë·ªïi ch·∫ø ƒë·ªô t·ªëi
    setExpression(expression.replace('S√°ng | T·ªëi | Xanh | ƒê∆°n gi·∫£n', `Ch·∫ø ƒë·ªô: ${theme}`)); // C·∫≠p nh·∫≠t ch·∫ø ƒë·ªô
    setShowThemes(false); // ·∫®n l·ª±a ch·ªçn ch·∫ø ƒë·ªô
  };

  // H√†m x·ª≠ l√Ω khi b·∫≠t/t·∫Øt ch·∫ø ƒë·ªô hi·ªÉn th·ªã
  const handleOnOff = (value) => {
    setDisplayEnabled(value === 'ON'); // B·∫≠t ho·∫∑c t·∫Øt t√≠nh nƒÉng hi·ªÉn th·ªã
  };

  return (
    <View style={[styles.container, isDark && styles.darkContainer]}>
      {/* ƒêo·∫°n n√†y ch·ª©a c√°c n√∫t chuy·ªÉn ch·∫ø ƒë·ªô s√°ng/t·ªëi */}
      <View style={styles.switchContainer}>
        <Entypo name="light-up" size={24} color={isDark ? '#ccc' : '#333'} />
        <Switch value={isDark} onValueChange={() => setIsDark(!isDark)} />
        <Entypo name="moon" size={24} color={isDark ? '#ccc' : '#333'} />
      </View>

      {/* Ph·∫ßn hi·ªÉn th·ªã bi·ªÉu th·ª©c v√† con tr·ªè */}
      <View style={styles.themeContainer}>
        {showThemes ? (
          ['S√°ng', 'T·ªëi', 'Xanh', 'ƒê∆°n gi·∫£n'].map((option, index) => (
            <TouchableOpacity key={index} onPress={() => handleSelectTheme(option)}>
              <Text style={styles.themeOption}>{option}</Text>
            </TouchableOpacity>
          ))
        ) : (
          <Text style={[styles.expression, isDark && styles.darkExpression, { fontSize: 24, fontWeight: 'bold'}]}>
            {displayEnabled &&
              expression.split('\n').map((line, idx) => (
                <View key={idx} style={styles.themeContainer}>
                  {line.includes('S√°ng | T·ªëi | Xanh | ƒê∆°n gi·∫£n') ? (
                    line.split(' | ').map((option, i) => (
                      <TouchableOpacity key={i} onPress={() => handleSelectTheme(option)}>
                        <Text style={styles.themeOption}>{option}</Text>
                      </TouchableOpacity>
                    ))
                  ) : (
                    <Text style={styles.expression}>{line}</Text>
                  )}
                </View>
              ))}
            {/* Con tr·ªè nh·∫•p nh√°y */}
            {cursorIndex === expression.length && displayEnabled && (
              <Animated.Text
                style={{
                  color: cursorIndex % 2 === 0 ? 'blue' : 'green', // ƒê·ªïi m√†u khi di chuy·ªÉn con tr·ªè
                  opacity: blinkAnim, // Hi·ªáu ·ª©ng nh·∫•p nh√°y
                  fontSize: 24,
                  fontWeight: 'bold',
                }}
              >
                |
              </Animated.Text>
            )}
          </Text>
        )}
      </View>

      {/* Hi·ªÉn th·ªã k·∫øt qu·∫£ */}
      <Text style={[styles.result, isDark && styles.darkText]}>
        <Text>= </Text>{result}
      </Text>

      {/* L∆∞·ªõi c√°c n√∫t b·∫•m */}
      <View style={styles.buttonGrid}>
        {buttons.map((row, rowIndex) => (
          <View style={styles.row} key={rowIndex}>
            {row.map((btn, btnIndex) => {
              const isDisabled = !displayEnabled && btn !== 'ON';
              const btnOpacity = isDisabled ? 0.5 : 1;

              const buttonStyle = [
                styles.button,
                isDark && styles.darkButton,
                (btn === 'ON' && displayEnabled) && { borderWidth: 2, borderColor: 'green' },
                (btn === 'OFF' && !displayEnabled) && { borderWidth: 2, borderColor: 'red' },
                { opacity: btnOpacity },
              ];

              const handleButtonPress = () => {
                if (btn === 'ON' || btn === 'OFF') return handleOnOff(btn);
                if (isDisabled) return;
                if (btn === 'Giao di·ªán') return handleThemeSelection();
                if (btn === 'Ans') return handleAns();
                if (btn === '‚û°Ô∏è') return moveCursorRight();
                if (btn === '‚¨ÖÔ∏è') return moveCursorLeft();
                if (btn === 'AC') return deleteCharacter(); // X√≥a k√Ω t·ª± khi b·∫•m AC
                return handlePress(btn);
              };

              return (
                <TouchableOpacity
                  key={btnIndex}
                  style={buttonStyle}
                  onPress={handleButtonPress}
                  disabled={isDisabled}
                >
                  <Text style={styles.buttonText}>{btn}</Text>
                </TouchableOpacity>
              );
            })}
          </View>
        ))}
      </View>
    </View>
  );
}
